package sts

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	format                 = `format is "/path/to/file.go:struct_name"`
	ErrIncorectSourceParam = errors.New(`incorrect source, ` + format)
	ErrIncorectDestParam   = errors.New(`incorrect destination, ` + format)
)

// split splits string by ":" into two parts.
func split(s string) (string, string) {
	parts := strings.Split(s, ":")
	if len(parts) != 2 {
		return "", ""
	}

	return parts[0], parts[1]
}

// pkgFromPath returns package name as last elements from path.
func pkgFromPath(p string) string {
	s := strings.Split(p, "/")
	return s[len(s)-1]
}

// Tags to inspect:
// * sts
// * custom
func Run(
	// source and destination structures in format <path/to/*.go file>:<structure>
	src, dst string,
	sourceTag string, // Tag on source structure.
	validDstTags string, // Comma-separated list of tags on destination structure.
	outputDir string,
	hpkg string, // Package name with helper functions.
	version string, // App version.
	debug bool, // If true, add debug info to output file.
	cfgmap *FieldConfig, // field map from yaml config
) (string, []byte, error) {
	sf, ssn := split(src)
	if sf == "" || ssn == "" {
		return "", nil, ErrIncorectSourceParam
	}

	df, dsn := split(dst)
	if df == "" || dsn == "" {
		return "", nil, ErrIncorectDestParam
	}

	parsedSrc, err := Parse(sf, []string{sourceTag})
	if err != nil {
		return "", nil, err
	}

	ss, ok := parsedSrc.Structs[ssn]
	if !ok {
		return "", nil, fmt.Errorf("source structure %q not found: ", ssn)
	}

	vt := strings.Split(validDstTags, ",")

	parsedDst, err := Parse(df, vt)
	if err != nil {
		return "", nil, err
	}

	ds, ok := parsedDst.Structs[dsn]
	if !ok {
		return "", nil, fmt.Errorf("destination structure %q not found: ", dsn)
	}

	abs, err := filepath.Abs(outputDir)
	if err != nil {
		return "", nil, err
	}
	opkg := pkgFromPath(abs)

	// do not use package name for structures when destination package is the
	// same as output one.
	srcp, dstp := parsedSrc.Package, parsedDst.Package
	if srcp == opkg {
		srcp = ""
		dstp = ""
	}

	linkedFields, err := link(ss, ds, sourceTag, vt, cfgmap)
	if err != nil {
		return "", nil, err
	}

	ff := newTemplate(ssn, dsn, srcp, dstp, linkedFields)

	fmt.Fprintf(ff, "// Code generated by sts v%s. DO NOT EDIT.\n\npackage %s\n\n", version, opkg)

	err = ff.Print(false, debug, hpkg)
	if err != nil {
		return "", nil, err
	}

	err = ff.Print(true, debug, hpkg)
	if err != nil {
		return "", nil, err
	}

	ff.PrintWithBothPointers(false)
	ff.PrintWithBothPointers(true)

	//=====

	// List of values on the left => list of value on the right
	ff.PrintList(false, false, false)
	ff.PrintList(true, false, false)

	ff.PrintList(false, false, true)
	ff.PrintList(true, false, true)

	ff.PrintList(false, true, false)
	ff.PrintList(true, true, false)

	ff.PrintList(false, true, true)
	ff.PrintList(true, true, true)

	ic, err := imports.Process("output.go", ff.Bytes(), nil)
	if err != nil {
		return "", nil, err
	}

	ff.Reset()
	ff.Write(ic)

	if ssn == dsn {
		ssn = srcp + "_" + ssn
		dsn = dstp + "_" + dsn
	}

	ofile := filepath.Join(
		outputDir, strings.ToLower(fmt.Sprintf("%s_to_%s.sts.go", ssn, dsn)),
	)

	return ofile, ff.Bytes(), nil
}
