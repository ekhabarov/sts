package sts

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	format                 = `format is "/path/to/file.go:struct_name"`
	ErrIncorectSourceParam = errors.New(`incorrect source, ` + format)
	ErrIncorectDestParam   = errors.New(`incorrect destination, ` + format)
)

// split splits string by ":" into two parts.
func split(s string) (string, string) {
	parts := strings.Split(s, ":")
	if len(parts) != 2 {
		return "", ""
	}

	return parts[0], parts[1]
}

// pkgFromPath returns package name as last elements from path.
func pkgFromPath(p string) string {
	s := strings.Split(p, "/")
	return s[len(s)-1]
}

// Tags to inspect:
// * sts
// * custom
func Run(
	// source and destination structures in format <path/to/*.go file>:<structure>
	src, dst string,
	sourceTag string, // Tag on source structure.
	validDstTags string, // Comma-separated list of tags on destination structure.
	outputDir string,
	hpkg string, // Package name with helper functions.
	version string, // App version.
	debug bool, // If true, add debug info to output file.
) (string, []byte, error) {
	sf, ssn := split(src)
	if sf == "" || ssn == "" {
		return "", nil, ErrIncorectSourceParam
	}

	df, dsn := split(dst)
	if df == "" || dsn == "" {
		return "", nil, ErrIncorectDestParam
	}

	parsedSrc, err := Parse(sf, nil, []string{sourceTag})
	if err != nil {
		return "", nil, err
	}

	vt := strings.Split(validDstTags, ",")

	parsedDst, err := Parse(df, nil, vt)
	if err != nil {
		return "", nil, err
	}

	abs, err := filepath.Abs(outputDir)
	if err != nil {
		return "", nil, err
	}
	opkg := pkgFromPath(abs)

	// do not use package name for structures when destination package is the
	// same as output one.
	srcp, dstp := parsedSrc.Package, parsedDst.Package
	if srcp == opkg {
		srcp = ""
		dstp = ""
	}

	ss, ok := parsedSrc.Structs[ssn]
	if !ok {
		return "", nil, fmt.Errorf("source structure %s not found", ssn)
	}

	ds, ok := parsedDst.Structs[dsn]
	if !ok {
		return "", nil, fmt.Errorf("destination structure %s not found", dsn)
	}

	linkedFields, err := link(ss, ds, sourceTag, vt)
	if err != nil {
		return "", nil, err
	}

	ff := newTemplate(ssn, dsn, srcp, dstp, linkedFields)

	fmt.Fprintf(ff, `// Auto-generated code. DO NOT EDIT!!!
// Generated by sts v%s.

package %s

`, version, opkg)

	err = ff.Print(false, debug, hpkg)
	if err != nil {
		return "", nil, err
	}

	err = ff.Print(true, debug, hpkg)
	if err != nil {
		return "", nil, err
	}

	ic, err := imports.Process("output.go", ff.Bytes(), nil)
	if err != nil {
		return "", nil, err
	}

	ff.Reset()
	ff.Write(ic)

	ofile := filepath.Join(
		outputDir, strings.ToLower(fmt.Sprintf("%s_to_%s.go", ssn, dsn)),
	)

	return ofile, ff.Bytes(), nil
}
